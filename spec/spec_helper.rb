# This file was generated by the `rails generate rspec:install` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause this
# file to always be loaded, without a need to explicitly require it in any files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, make a
# separate helper file that requires this one and then use it only in the specs
# that actually need it.
#
# The `.rspec` file also contains a few flags that are not defaults but that
# users commonly want.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration

ENV['RACK_QUEUE_METRICS_INTERVAL'] = "#{(3600 * 24)}"
ENV["RAILS_ENV"] ||= 'test'
if ENV['RAILS_ENV'] == 'development'
  ENV['RAILS_ENV'] = 'test'
end
ENV['REDIS_URL'] ||= 'redis://localhost:6379'
ENV['TWILIO_CALLBACK_HOST'] ||= 'test.com'
ENV['CALL_END_CALLBACK_HOST'] ||= 'test.com'
ENV['INCOMING_CALLBACK_HOST'] ||= 'test.com'
ENV['VOIP_API_URL'] ||= 'test.com'
ENV['TWILIO_CALLBACK_PORT'] ||= '80'
ENV['RECORDING_ENV'] = 'test'
ENV['CALLIN_PHONE'] ||= '5555551234'
ENV['DIAL_QUEUE_AVAILABLE_LIMIT'] ||= '10'

# require 'rubygems'
require File.expand_path("../../config/environment", __FILE__)
require 'rspec/rails'
require 'webmock/rspec'

Capybara.javascript_driver = :webkit

VCR.configure do |c|
  if ENV['RAILS_ENV'] == 'e2e'
    c.allow_http_connections_when_no_cassette = true
  else
    c.cassette_library_dir = Rails.root.join 'spec/fixtures/vcr_cassettes'
    c.hook_into :webmock
  end
end
# Requires supporting ruby files with custom matchers and macros, etc,
# in spec/support/ and its subdirectories.
Dir[Rails.root.join("spec/support/**/*.rb")].each {|f| require f}
Dir[Rails.root.join("spec/shared/**/*.rb")].each {|f| require f}

RSpec.configure do |config|
# The settings below are suggested to provide a good initial experience
# with RSpec, but feel free to customize to your heart's content.
  begin
    config.infer_spec_type_from_file_location!

    config.include FactoryGirl::Syntax::Methods
    config.include TwilioRequestStubs
    config.include FactoryGirlImportHelpers

    config.before(:suite) do
      WebMock.allow_net_connect!

      if ENV['RAILS_ENV'] == 'e2e'
        Capybara.javascript_driver = :webkit
        DatabaseCleaner.strategy = :truncation
      else
        DatabaseCleaner.strategy = :transaction
      end
      DatabaseCleaner.clean_with :truncation

      module ImpactPlatform::Heroku::UploadDownloadHooks
        alias_method :real_after_enqueue_scale_up, :after_enqueue_scale_up

        def after_enqueue_scale_up(*args); end
      end
    end

    config.after(:suite) do
      DatabaseCleaner.clean
      
      module ImpactPlatform::Heroku::UploadDownloadHooks
        alias_method :after_enqueue_scale_up, :real_after_enqueue_scale_up
      end
    end

    config.before(:each) do
      DatabaseCleaner.start
    end

    config.after(:each) do
      DatabaseCleaner.clean
    end

    # If you're not using ActiveRecord, or you'd prefer not to run each of your
    # examples within a transaction, remove the following line or assign false
    # instead of true.
    if ENV['RAILS_ENV'] == 'e2e'
      config.use_transactional_fixtures = false
    else
      config.use_transactional_fixtures = true
    end

    config.fixture_path = Rails.root.join('spec/fixtures')

    # These two settings work together to allow you to limit a spec run
    # to individual examples or groups you care about by tagging them with
    # `:focus` metadata. When nothing is tagged with `:focus`, all examples
    # get run.
    config.filter_run :focus
    config.run_all_when_everything_filtered = true

    # Many RSpec users commonly either run the entire suite or an individual
    # file, and it's useful to allow more verbose output when running an
    # individual spec file.
    if config.files_to_run.one?
      # Use the documentation formatter for detailed output,
      # unless a formatter has already been configured
      # (e.g. via a command-line flag).
      config.default_formatter = 'doc'
    end

    # Print the 10 slowest examples and example groups at the
    # end of the spec run, to help surface which specs are running
    # particularly slow.
    config.profile_examples = 10

    # Run specs in random order to surface order dependencies. If you find an
    # order dependency and want to debug it, you can fix the order by providing
    # the seed, which is printed after each run.
    #     --seed 1234
    config.order = :random

    # Seed global randomization in this process using the `--seed` CLI option.
    # Setting this allows you to use `--seed` to deterministically reproduce
    # test failures related to randomization by passing the same `--seed` value
    # as the one that triggered the failure.
    Kernel.srand config.seed

    # rspec-expectations config goes here. You can use an alternate
    # assertion/expectation library such as wrong or the stdlib/minitest
    # assertions if you prefer.
    config.expect_with :rspec do |expectations|
      # Enable only the newer, non-monkey-patching expect syntax.
      # For more details, see:
      #   - http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax
      expectations.syntax = :expect
    end

    # rspec-mocks config goes here. You can use an alternate test double
    # library (such as bogus or mocha) by changing the `mock_with` option here.
    config.mock_with :rspec do |mocks|
      # Enable only the newer, non-monkey-patching expect syntax.
      # For more details, see:
      #   - http://teaisaweso.me/blog/2013/05/27/rspecs-new-message-expectation-syntax/
      mocks.syntax = :expect

      # Prevents you from mocking or stubbing a method that does not exist on
      # a real object. This is generally recommended.
      mocks.verify_partial_doubles = true
    end
  end
end

include ActionDispatch::TestProcess

def login_as(user)
  allow(@controller).to receive(:current_user).and_return(user)
  session[:user] = user.id
  session[:caller] = user.id
end

def http_login
  name = AdminController::USER_NAME
  password = AdminController::PASSWORD
  if page.driver.respond_to?(:basic_auth)
    page.driver.basic_auth(name, password)
  elsif page.driver.respond_to?(:basic_authorize)
    page.driver.basic_authorize(name, password)
  elsif page.driver.respond_to?(:browser) && page.driver.browser.respond_to?(:basic_authorize)
    page.driver.browser.basic_authorize(name, password)
  else
    raise "I don't know how to log in!"
  end
end

def create_user_and_login
  user = build :user
  visit '/client/login'
  fill_in 'Email address', :with => user.email
  fill_in 'Pick a password', :with => user.new_password
  click_button 'Sign up'
  click_button 'I and the company or organization I represent accept these terms.'
end

def web_login_as(user)
  visit '/client/login'
  fill_in 'Email', with: user.email
  fill_in 'Password', with: 'password'
  click_on 'Log in'
end

def caller_login_as(caller)
  visit '/caller/login'
  fill_in 'Username', with: caller.username
  fill_in 'Password', with: caller.password
  click_on 'Log in'
end

def fixture_path
  Rails.root.join('spec/fixtures/').to_s
end

def fixture_file_upload(path, mime_type = nil, binary = false)
  Rack::Test::UploadedFile.new("#{fixture_path}#{path}", mime_type, binary)
end
